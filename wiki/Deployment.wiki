#summary Common class loading pitfalls.
#labels Phase-Design

The classloader in rupy is very simplistic, so you have to be careful how you write your hot-deployable code and what you store in the session. We recommend that you don't store hot-deployable classes with the {{{Session.put(key, value)}}} method, since {{{Session.get(key)}}} will throw a {{{ClassCastException}}} if you hot-deploy your application.

*Think small*

We serialze our beans to byte arrays that we store in the session. Because _byte_ is a bootclasspath class, old sessions can keep running the old code while new sessions run the new code without classloading issues. The user experience of a hot-deployment is seamless.

Another positive side-effect of limitations in Rupy is the lack of hot-deployed libs; since we only hot-deploy the application code (and libs are added to the bootclasspath) your server runs out of memory later rather than sooner!

*Common problems* (in order of popularity)

  * Make sure the hot-deployed classes are not in the bootclasspath.
  * Don't try to load a hot-deployed class with {{{Class.forName(String)}}}.
  * All classes have to have a void attribute constructor.
  * Inner classes need to be public static.
  * Implemented interfaces in the bootclasspath need to be public, even if the hot-deployed implementing class is in the same package.