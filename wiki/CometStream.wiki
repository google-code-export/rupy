#summary How to stream chunks in real-time.
#labels Featured,Phase-Implementation

You can now [http://rupy.googlecode.com/files/talk-1.0.zip stream] messages over HTTP with rupy.

As [http://www.ietf.org/id/draft-talk-comet-stream-protocol-00.txt RFC] specification I supply this reference implementation.

The message performance of the test included above:<br>

||CPU (s)||usage||in/s||out/s||total/s||
||3770S (4)||0%||~4.000||~9.000||~13.000||
||D510MO (2)||80-120%||~3.000||~6.000||~9.000||
||RPi (1)||99%||~300||~700||~1.000||

You can try it quickly by right-clicking these two links and opening <br>
them in new windows (so you can see the stream in real-time):

  | [http://one.rupy.se/pull?name=one one] | < "hello" | [http://one.rupy.se/push?name=two&message=hello two] |

  You will then send "hello" from <i>two</i> to <i>one</i>. <br>
  Reloading <i>two</i> will resend the message.<br>
  You can play around with more windows <br>
  and <i>name=[http://one.rupy.se/pull?name=three three]&message=[http://one.rupy.se/push?name=two&message=hi hi]</i> values.

  If it doesn't work, try later or on host _two.rupy.se_ or <br>
  _tre.rupy.se_, somebody else might be trying it at the <br>
  same time.

  IE doesen't render until a certain amount is <br>
  received, so hold down F5 in <i>two</i> for a while.

This code allows you to receive dynamic chunks with flash:

{{{
package {
	import flash.display.*;
	import flash.system.*;
	import flash.errors.*;
	import flash.events.*;
	import flash.utils.*;
	import flash.text.*;
	import flash.net.*;

	public class stream extends flash.display.MovieClip {
		var host = "talk.rupy.se";
		var port = 80;
		var pull;
		var push;
		var i = 1;
		var output;
		var first = true;
		
		public function stream() {
			output = new TextField();
			output.width = 450;
			output.height = 450;
			output.multiline = true;
			
			addChild(output);

			try {
				pull = socket(pull_data, pull_connect);
				push = socket(push_data, push_connect);
			} catch(error) {
				output.appendText(error + "\n");
			}
		}

		function socket(data, connect):Socket {
			var socket = new Socket();
			socket.addEventListener(IOErrorEvent.IO_ERROR, error);
			socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, error);
			socket.addEventListener(ProgressEvent.SOCKET_DATA, data); 
			socket.addEventListener(Event.CONNECT, connect);
			socket.connect(host, port);
			return socket;
		}

		function pull_connect(event) {
			pull.writeUTFBytes("GET /pull?name=one HTTP/1.1\r\n");
			pull.writeUTFBytes("Host: " + host + "\r\n");
			pull.writeUTFBytes("Head: less\r\n");
			pull.writeUTFBytes("\r\n");
			pull.flush();
		}

		function push_connect(event) {
			var timer = new Timer(30, 60);
			timer.addEventListener(TimerEvent.TIMER, tick);
			timer.start();
		}
		
		function tick(event) {
			push.writeUTFBytes("POST /push HTTP/1.1\r\n");
			push.writeUTFBytes("Host: " + host + "\r\n");
				
			if(first) {
				push.writeUTFBytes("Head: less\r\n"); // tells rupy to not send any headers
				first = false;
			}
				
			push.writeUTFBytes("\r\n");
			push.writeUTFBytes("name=two&message=" + i++);
			push.flush();
		}

		function push_data(event) {
			var message = push.readUTFBytes(event.bytesLoaded);
			//output.appendText(message + "\n"); // HTTP/1.1 200 OK
		}
		
		function pull_data(event) {
			var message = pull.readUTFBytes(event.bytesLoaded);
			var array = message.split("\r\n");
			for(var i = 1; i < array.length; i += 2) {
				output.appendText(array[i]);
			}
		}

		function error(event) {
			output.appendText(event + "\n");
		}
	}
}
}}}

Demo: [http://talk.rupy.se/stream.html]

Tutorial:

  * Create 2 new files:
    # _ActionScript_ - Paste the code above into it and save it as stream.as.
    # _Flash (AS 3.0)_ - Edit the Class to 'stream' in the PROPERTIES PUBLISH pane on the right, save in the same folder.
  * Then run Control -> Test Movie (Ctrl+Enter).