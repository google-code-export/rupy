#summary How to build completely async proxy chains with zero thread and memory footprint.
#labels Featured,Phase-Design,Phase-Implementation

{{{
public static class AsyncClient extends Service {
	CloseableHttpAsyncClient client = HttpAsyncClients.createDefault();

	public void create(Daemon daemon) {
		client.start();
	}
        
	public String path() { return "/plasma"; }
	public void filter(Event event) throws Event, Exception {
		Output out = event.output();

		if(event.push()) {
			HttpResponse response = (HttpResponse) event.query().get("response");
			Deploy.pipe(response.getEntity().getContent(), out);
			event.output().finish();
			out.flush();
		}
		else {
			event.hold();

			HttpGet request = new HttpGet("http://www.apache.org/");
			EventFutureCallback callback new EventFutureCallback<HttpResponse>(event)
			Future<HttpResponse> future = client.execute(request, callback);

			out.println("Async response started!");
			out.flush();
		}
	}

	public static class EventFutureCallback<T> implements FutureCallback {
		Event event;
		public EventFutureCallback(Event event) {
			this.event = event;
		}
		public void completed(Object result) {
			HttpResponse response = (HttpResponse) result;
				
			event.query().put("response", response);
			event.reply().wakeup();
		}
		public void failed(final Exception e) {
			System.out.println("Failed " + e);
		}
		public void cancelled() {
			System.out.println("Cancelled");
		}
	}
}
}}}