#summary How to build completely async proxy chains.
#labels Featured,Phase-Design,Phase-Implementation

This [http://test.rupy.se/plasma?host=www.aftonbladet.se example] proxies data all the way from a rather large swedish homepage to your browser via a rupy instance on a raspberry pi with zero thread iowait and memory footprint. You can try to refresh the page and view the [http://monitor.rupy.se monitor] to see CPU usage.


If you wan't to use microservices this is the most performant way to build your network. You can even use this as a load balancer.

{{{
public static class Plasma extends Service {
	CloseableHttpAsyncClient client;
	public void create(Daemon daemon) {
		client = HttpAsyncClients.createMinimal();
		client.start();
	}
	public void destroy() {
		client.close();
	}
	public String path() { return "/plasma"; }
	public void filter(Event event) throws Event, Exception {
		event.query().parse();
		Output out = event.output();
		String host = event.string("host");

		if(event.push()) {
			HttpResponse response = (HttpResponse) event.query().get("response");
			Deploy.pipe(response.getEntity().getContent(), out);
			event.output().finish();
			out.flush();
		}
		else {
			event.hold();

			HttpGet request = new HttpGet("http://" + host);
			EventFutureCallback callback new EventFutureCallback<HttpResponse>(event);
			Future<HttpResponse> future = client.execute(request, callback);

			out.println("Async response started!");
			out.flush();
		}
	}

	public static class EventFutureCallback<T> implements FutureCallback {
		Event event;
		public EventFutureCallback(Event event) {
			this.event = event;
		}
		public void completed(Object result) {
			HttpResponse response = (HttpResponse) result;
				
			event.query().put("response", response);
			event.reply().wakeup();
		}
		public void failed(final Exception e) {
			System.out.println("Failed " + e);
		}
		public void cancelled() {
			System.out.println("Cancelled");
		}
	}
}
}}}