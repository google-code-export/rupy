#summary Why yet another Java HTTP server?
#labels Phase-Design

_"Size matters, and less is more!"_

*Modularity* 

 Ideally, you should be able to choose your tools and fix or replace a broken tool quickly. That's what modular software is all about, like binary lego. If you need a JSP compiler, _choose_ a JSP compiler!

*Creativity*

 Or why not build your own JSP compiler? Actually we figured that generating Java from HTML to services and precompiling before deploy would accelerate development; so we built a [http://rupy.googlecode.com/files/page-0.2.zip generator], hope you like it!

 In general we recommend that you be creative about how to solve _your_ technical challenges without the use of multi-purpose high-level tools.

*Simplicity*

 Rupy is SOS (Simple Open-Source) you should be able to understand the codebase enough to comfortably modify it during a coffee-break. Superposing of desired features should be hesitationless.

*Agility*

 With rupy you can hot-replace a major refactoring, if you serialize your session data, without _any_ kind of interruption for your end users and _directly_ from your development station to the live environment. Let your users do the QA!

*Speed and Scalability*

 Why not have both, the compact codebase inherently provides high speed, which still gracefully degrades thanks to non-blocking asynchronous IO and an event queue to avoid selector trashing.

*Design*

 At the end of 2003, Greg Wilkins, the author of the Jetty Web container and contributor to the Servlet specifications, blogged about some issues with Servlets: 

  * No clear separation between the protocol concerns and the application concerns. 
  * Unable to take full advantage of the non-blocking NIO due to blocking IO assumptions. 
  * Full Servlet Web containers are overkill for many applications. 

 Source: http://www.restlet.org/about/introduction