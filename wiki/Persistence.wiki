#summary Secure Unique Identity Cluster.
#labels Phase-Design,Phase-Implementation

This requires latest [http://rupy.se/rupy.zip rupy] in hosted mode.

For true redundancy you need to use some custom cluster database since we [http://host.rupy.se host] across multiple colocations!
Ordinary databases are not secure or redundant in a distributed cluster environment out of the box, but most of all:

  _Database clients don't use async HTTP; you can't scale them easily._

On the other hand modern file systems are now cheap and fast (ext4 on PCIe SSD) and async is becoming common place; See the entry on [https://code.google.com/p/rupy/wiki/Fuse fuse] to learn more on how you can scale any [https://code.google.com/p/rupy/wiki/Process ÂµSOA] cluster.
My first implementation of this cluster database will be a solution to user and node management with sort index and link graph.

Root takes a little bit from all NoSQL databases: document, key-value and graph; It's basically a key-value (Base58-JSON) store with custom indexing (that we call sort) of fields in the JSON and graph relationships between the key-values.

The JSON objects and indexes are stored as a plain file (symbolic hard link). The relations is just a binary file with a list of longs (the hashed Base58 key). Simple, powerful and in line with _Moore's_ and _Murphy's_ laws.

Try the [http://root.rupy.se current] version.

TODO:

  # ~~new [https://code.google.com/p/rupy/source/browse/trunk/src/se/rupy/http/Async.java async] client~~
  # ~~edit _node_~~<sup>1</sup>
  # ~~sort _node_ index~~<sup>1</sup>
  # ~~link _node_ graph~~<sup>1</sup>

Source: [http://root.rupy.se/code?path=/User.java User.java], [http://root.rupy.se/code?path=/Root.java Root.java]

<sup>1</sup> The root cluster database will not re-synchronize data for you after a failed operation (edit/link node down), you will have to do that manually. It will however perfectly replicate and make sure nothing gets linked twice when all nodes are up. It's write sensitive, but read strong.