#summary Secure Unique Identity Cluster.
#labels Phase-Design,Phase-Implementation

This requires latest [http://rupy.se/rupy.zip rupy] in hosted mode.

For true redundancy you need to use some custom cluster datastore since we [http://host.rupy.se host] across multiple colocations!

Ordinary databases are not secure or redundant in a distributed cluster environment, but most of all:

  * Databases don't have NIO; you can't scale them.

On the other hand modern file systems are now B-Tree indexed and capable of scaling.

My first implementation of this "database" will be a solution to the never ending user registration/login duplication.

TODO:

  # [https://code.google.com/p/rupy/wiki/Fuse async]
  # link key index
  # add name and mail link index
  # add pass field

Current `<`id`>` file:

{{{
{
	"key": "as4df5gh6jk7zx4c", 
	"name": "xxx", 
	"mail": "yyy@zzz.com", 
	"pass": "xyz", 
	"data": {
		"www.aeonalpha.com": <blabla>, 
		"www.bitcoinbankbook.com": <blabla>
	}
}
}}}

For the code below:

  # sync any file

<font color="red">
_Work in progress:<br><br>This current version is redundant for reads, but not for writes, meaning for example:<br>If part of the cluster is down; you will still be able to login, but registrations will fail.<br>The tradeoffs for write uptime are under consideration._

{{{
/**
 * Secure Unique Identity Cluster.
 * 
 * This solution is "wasteful"; but with 16-digit Base24 keys and 
 * long ids, collisions should be rare, at least over the network.
 * 
 * To use this you need to configure three additional DNS entries:
 * 
 * one.your.app.domain -> 89.221.241.32
 * two.your.app.domain -> 89.221.241.33
 * tre.your.app.domain -> 92.63.174.125
 * 
 * If you want to index by e-mail or username you need to change 
 * that part of the code too.
 */
public class Root extends Service {
	static {
		// Since your DNS provider is VERY likely to screw things up: use IPs!
		System.setProperty("sun.net.http.allowRestrictedHeaders", "true");
	}
	
	static String local;
	static Deploy.Archive archive;
	
	static String[] hosts = {"one", "two", "tre"};
	static String[] ips = {"89.221.241.32", "89.221.241.33", "92.63.174.125"};

	public String path() { return "/root"; }

	public void create(Daemon daemon) throws Exception {
		local = InetAddress.getLocalHost().getHostName();
		archive = (Deploy.Archive) Thread.currentThread().getContextClassLoader();
		
		// TODO: connect to other cluster nodes and compare checksum of root folder!
		// If mismatch, make files checksum diff and sync!
	}

	public void filter(Event event) throws Event, Exception {
		boolean found = false;

		for(int i = 0; i < ips.length; i++) {
			if(ips[i].equals(event.remote())) {
				found = true;
			}
		}

		Output out = event.output();

		if(event.query().method() == Query.POST && found) {
			ByteArrayOutputStream data = new ByteArrayOutputStream();
			Deploy.pipe(event.input(), data);
			String key = decrypt(data.toByteArray());

			//System.out.println(key);

			try {
				store(key);
				out.print(1);
			}
			catch(KeyException e) {
				out.print(0);
			}
			catch(Exception e) {
				e.printStackTrace();
				out.print(-1);
			}
		}
		else {
			out.print(-1);
		}
	}

	static int send(int id, byte[] data) throws Exception {
		String url = "http://" + ips[id] + "/root";
		HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
		conn.addRequestProperty("Content-length", "" + data.length);
		conn.addRequestProperty("Host", hosts[id] + "." + archive.host());
		conn.setRequestMethod("POST");
		conn.setConnectTimeout(500);
		conn.setDoOutput(true);

		ByteArrayInputStream in = new ByteArrayInputStream(data);
		OutputStream out = conn.getOutputStream();

		Deploy.pipe(in, out);

		out.close();

		if(conn.getResponseCode() == 200) {
			return new BufferedReader(new InputStreamReader(conn.getInputStream())).read();
		}

		return -1;
	}

	/**
	 * Create and synchronize a unique user key and identity across the cluster.
	 * The id is generated by hashing the key with {@link #hash(String)}.
	 */
	public static String create() throws Exception {
		String key;

		do {
			key = Event.random(16);
		}
		while(exists(key, true) == 0);

		store(key);

		return key;
	}

	/**
	 * Fetch the identity of a user key. Equivalent of "login". The validation of 
	 * the user key is that the file is present. 
	 */
	public static long id(String key) throws Exception {
		JSONObject o = new JSONObject(file("app/" + archive.host() + "/root/key" + path(key)));

		return o.getLong("id");
	}

	static int exists(String key, boolean remote) throws Exception {
		long id = hash(key);

		String prefix = "app/" + archive.host() + "/root";
		
		if(id < 4) // Reserved for developer
			return 0;

		if(new File(prefix + path(key)).exists() || new File(prefix + path(id)).exists())
			return 0;

		if(!remote)
			return 1;

		byte[] data = encrypt(key);

		for(int i = 0; i < hosts.length; i++) {
			if(!hosts[i].equals(local)) {
				int result = send(i, data);
				
				if(result < 0) {
					throw new KeyException("Node [" + hosts[i] + "] failed.");
				}
				
				if(result < 1) {
					return 0;
				}
			}
		}

		return 1;
	}

	public static class KeyException extends Exception {
		public KeyException(String message) { super(message); }
	}

	static void store(String key) throws Exception {
		if(exists(key, false) == 0)
			throw new KeyException("Node [" + local + "] collision.");

		long id = hash(key);

		String prefix = "app/" + archive.host() + "/root";
		
		write(new File(prefix + "/key" + path(key)), "{\"id\": " + id + "}");
		write(new File(prefix + "/id" + path(id)), "{\"key\": \"" + key + "\"}");
	}

	static void write(File file, String content) throws Exception {
		File path = new File(file.getPath().substring(0, file.getPath().lastIndexOf("/")));
		path.mkdirs();

		file.createNewFile();

		BufferedWriter output = new BufferedWriter(new FileWriter(file));
		output.write(content);
		output.close();
	}

	static long hash(String key) throws Exception {
		long h = 2166136261L;

		for(int i = 0; i < key.length(); i++) {
			h = (h ^ key.charAt(i)) * 16777619;
		}

		return Math.abs(h);
	}

	static String path(long id) {
		return path(String.valueOf(id));
	}

	/* The path is folders of the first four characters then a file of the remainder.
	 * With Ext4 this shouldn't be required, but I think it might offload the index?
	 */
	static String path(String key) {
		StringBuilder path = new StringBuilder("/");

		for(int i = 0; i < key.length(); i++) {
			if(i < 5) {
				path.append("/");
			}

			path.append(key.charAt(i));
		}

		return path.toString();
	}

	/*
	 * Encryption stuff
	 */
	
	static String secret;

	static String secret() throws Exception {
		if(secret == null) {
			secret = file("app/" + archive.host() + "/secret");
		}

		return secret;
	}

	static String file(String path) throws Exception {
		RandomAccessFile file = new RandomAccessFile(new File(path), "r");
		String content = file.readLine();
		file.close();
		
		return content;
	}
	
	public static class Protect extends Service {
		public String path() {
			return "/secret";
		}

		public void filter(Event event) throws Event, Exception {
			event.output().println("Nice try!");
		}
	}

	static byte[] encrypt(String text) throws Exception {
		Cipher aes = Cipher.getInstance("AES/ECB/PKCS5Padding");
		aes.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(secret().getBytes(), "AES"));
		return aes.doFinal(text.getBytes());
	}

	static String decrypt(byte[] data) throws Exception {
		Cipher aes = Cipher.getInstance("AES/ECB/PKCS5Padding");
		aes.init(Cipher.DECRYPT_MODE, new SecretKeySpec(secret().getBytes(), "AES"));
		return new String(aes.doFinal(data));
	}
}
}}}