#summary How to fuse HTTP network async.
#labels Phase-Design

This requires latest [http://rupy.se/rupy.zip rupy] and [http://root.rupy.se/code Async.java].

<font color="red">
_Work in progress: Async.java is very stable, but we have not implemented chunked responses yet._
</font>

This is how the current client/server tools we use work:

{{{
TIME <----------------  goes forth & back  -------------------------->

WAIT      ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

+--------+    +---------+                   +---------+    +---------+
|        | -> |         | --+-------------> |         |    |         |
|  brow  |    |  crap1  |   |               |  crap2  | .. |  serv2  |
|        | <- |         | <---+------------ |         |    |         |
+--------+    +---------+   | |             +---------+    +---------+
                            | |
                            | +---------+
                            +---------+ |
                                      | |
                                  +---------+
                                  |         |
                                  |  serv1  |
                                  |         |
                                  +---------+
}}}

The idea is to wait only in the network (no related <font color="red">`IO-wait`</font>) and to wait for multiple things at the same time:

{{{
TIME <----------------  goes forth & back  --------------------->

WAIT      ↓↓↓↓           ↓↓↓↓↓↓↓↓↓           ↓↓↓↓

+--------+    +---------+         +---------+    +---------+
|        | -> |         | --+---> |         |    |         |
|  brow  |    |  node1  |   |     |  node2  | .. |  serv2  |
|        | <- |         | <---+-- |         |    |         |
+--------+    +---------+   | |   +---------+    +---------+
                            | |
                            | +---------+
                            +---------+ |
                                      | |
                                  +---------+
                                  |         |
                                  |  serv1  |
                                  |         |
                                  +---------+
}}}

  * `brow` = <font color="CD5C5C">`sync`</font> `req`         <font color="grey">= `browser`</font>
  * `crap` = <font color="CD5C5C">`sync`</font> `req` & `res` <font color="green">= `your grandma's web`</font>
  * `node` = <font color="5CCD5C">`asyn`</font> `req` & `res` <font color="green">= `fuse`</font>
  * `serv` = <font color="CD5C5C">`sync`</font> `res`         <font color="grey">= `server`</font>

For this we introduce a new concept; the <font color="green">`fuse`</font> `node`;
so today only your database is a true `server`. 
What you have as a `"server"` is probably something which <font color="CD5C5C">`sync`</font> `req` & `res` data.

Time and <font color="red">`IO-wait`</font> is shown in the graph below:

  # = <font color="CD5C5C">`sync`</font> `req` & `res` <font color="grey">= `your web server`</font>
  # = <font color="5CCD5C">`asyn`</font> `req` <font color="grey">= `netflix`</font>
  # = <font color="5CCD5C">`asyn`</font> `req` & `res` <font color="green">= `fuse`</font>

http://rupy.se/fuse.gif

This [http://root.rupy.se/fuse example] fuses data <font color="5CCD5C">`asyn`</font> from multiple servers to your browser via a rupy <font color="green">`fuse`</font> `node` on a raspberry pi with zero thread <font color="red">`IO-wait`</font>.

Another use case for this is our cluster database [https://code.google.com/p/rupy/wiki/Persistence root].

If you want to use [https://code.google.com/p/rupy/wiki/Process µSOA] this is the most performant way to build your services network. You can even use this as a load balancer.
{{{
// TODO: Improve latch.
public static class Fuse extends Service {
	static Async async;

	public void create(Daemon daemon) throws Exception { async = new Async(true); async.start(5); }
	public void destroy() throws Exception { async.stop(); }
	public String path() { return "/fuse"; }

	public void filter(final Event event) throws Event, Exception {
		Output out = event.output();

		if(event.push()) {
			Http[] http = (Http[]) event.query().get("http");

			int done = 0;

			for(int i = 0; i < http.length; i++) {
				if(http[i].print()) {
					done++;
				}
			}

			if(done == http.length) {
				out.println("</body></html>");
				out.finish();
			}

			out.flush();
		}
		else {
			event.query().put("time", System.currentTimeMillis());
			event.reply().type("text/html; charset=UTF-8");
			event.hold();

			Http[] http = new Http[2];

			String path = "/v1/public/yql" +
			"?q=select%20*%20from%20yahoo.finance.xchange%20where%20pair%20in%20(%22USDSEK%22)" +
			"&format=json&env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys";

			http[0] = new Http("one", "strip.rupy.se", "/?a=martin+kellerman&body", event);
			http[1] = new Http("two", "query.yahooapis.com", path, event);

			for(int i = 0; i < http.length; i++) {
				// The 10 at the end is very important.
				// It means the socket will be kept alive 
				// for 10 seconds since last active.
				async.send(http[i].host, http[i], 10);
			}

			event.query().put("http", http);
		}
	}

	public static class Http extends Work {
		private String name;
		private String host;
		private String path;
		private String body;
		private Event event;

		public Http(String name, String host, String path, Event event) {
			this.name = name;
			this.host = host;
			this.path = path;
			this.event = event;
		}

		public boolean print() throws Exception {
			if(event.query().get(name) instanceof Http) {
				long time = System.currentTimeMillis() - event.big("time");
				System.out.println("  " + name + " " + time + " ms.");
				event.output().println(body);
				event.query().put(name, "done");
				return true;
			}
			else if(event.query().get(name) instanceof String) {
				return ((String) event.query().get(name)).equals("done");
			}

			return false;
		}

		public void send(Call call) throws Exception {
			call.get(path, "Host: " + host + "\r\n");
		}

		public void read(String body) throws Exception {
			this.body = body;
			event.query().put(name, this);
			System.out.println("  " + name + " success " + event.reply().wakeup());
		}

		public void fail(String host, Exception e) throws Exception {
			if(e instanceof Timeout) {
				System.out.println("  " + e);
				async.send(host, this, 10);
			}
			else {
				e.printStackTrace();
				event.query().put("response", e.toString());
				System.out.println("  " + name + " failure " + event.reply().wakeup());
			}
		}
	};
}
}}}