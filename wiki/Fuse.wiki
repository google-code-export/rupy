#summary How to build front & back async realtime HTTP proxy chains for µSOA.
#labels Featured,Phase-Design,Phase-Implementation

This [http://test.rupy.se/fuse example] proxies data from two sources (of which one is a never ending chunked stream) to your browser via a rupy instance on a raspberry pi with zero thread IO-wait and memory footprint. You can view the [http://monitor.rupy.se monitor] to see CPU usage (blue is IO-wait).

Time and <font color="red">*IO-wait*</font> is shown in the graph below:

  # Server & client sync.
  # Client async.
  # Fuse server & client async.

http://rupy.se/fuse.gif

If you wan't to use [https://code.google.com/p/rupy/wiki/Process µSOA] this is the most performant way to build your services network. You can even use this as a load balancer.

{{{
public static class Fuse extends Service {
	public String path() { return "/fuse"; }
	public void filter(final Event event) throws Event, Exception {
		if(event.push()) {
			Output out = event.output();
			HttpResponse one = (HttpResponse) event.query().get("poll");
			if(one != null) {
				Deploy.pipe(one.getEntity().getContent(), out);
				event.query().put("poll", null);
			}
			String two = (String) event.query().get("chunk");
			if(two != null) {
				out.println(two);
				event.query().put("chunk", null);
			}
			out.flush();
		}
		else {
			HttpGet one = new HttpGet("http://strip.rupy.se/?a=martin+kellerman&body");
			HttpGet two = new HttpGet("http://bank.rupy.se/pull?mail=" + System.currentTimeMillis());
			final CloseableHttpAsyncClient client = HttpAsyncClients.createMinimal();
			client.start();
			client.execute(one, new FutureCallback<HttpResponse>() {
				public void completed(final HttpResponse response) {
					event.query().put("poll", response);
					event.reply().wakeup();
				}
				public void failed(final Exception e) { e.printStackTrace(); }
				public void cancelled() {}
			});
			client.execute(HttpAsyncMethods.create(two), new AsyncCharConsumer<HttpResponse>() {
				HttpResponse response;
				protected void onResponseReceived(final HttpResponse response) { this.response = response; }
				protected void onCharReceived(final CharBuffer buf, final IOControl ioctrl) throws IOException {
					event.query().put("chunk", buf.toString());
					if(event.reply().wakeup() != Reply.OK) {
						ioctrl.shutdown();
						client.stop();
					}
				}
				protected void releaseResources() {}
				protected HttpResponse buildResult(final HttpContext context) { return this.response; }
			}, null);
		}
	}
}
}}}