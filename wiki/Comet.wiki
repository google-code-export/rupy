#summary HTTP reply in real-time.
#labels Phase-Implementation
If you want the HTTP server to send updates to the client you can use polling, where the client asks the server for updates at regular intervalls. But since this doesen't provide any real-time functionality, not to mention the performance overhead, modern HTTP bound applications use asynchronous reply instead.

The HTTP server only replies to the clients query when there is some new information to send. Your client basically 'hangs' in the meantime, so you will need to thread the client. This can be done simply in browsers fdsafdsa with [http://en.wikipedia.org/wiki/Ajax_%28programming%29 Ajax].

Some even setup two HTTP connections; one for outgoing data, one for incoming, and use chunked transfer encoding to stream data between client and server over HTTP just as if it was a normal TCP stream connection. This is called [http://svn.xantus.org/shortbus/trunk/bayeux/bayeux.html Bayeux].

Firewalls and proxies sometimes interrupt passive queries that linger for too long, so make sure your solution tears down and recreates the comet queries at regular intervalls.

This is an example of how you could wakeup rupy so that it will assign a worker thread to write your reply asynchronously:
{{{
import se.rupy.http.*;
public Comet extends Service {
	boolean update;
	Event cache;
	...
	public void filter(Event event) throws Event, Exception {
		if( ... ) {
			// you need to somehow cache the event
			cache = event;
		}
		else if( ... ) {
			// when you for example received a chat 
			// message destined to the cached client
			update = true;
			cache.reply().wakeup();
		}
		else if(update && event.index() == cache.index()) {
			Output out = event.output();
			... // write the message
			update = false;
		}
	}
}
}}}
Also see [http://en.wikipedia.org/wiki/Comet_%28programming%29 comet]. 